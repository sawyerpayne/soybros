<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-6</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Hitbox of projectile
hitbox = -1;
xScale = 0;
yScale = 0;
xOffset = 0;
yOffset = 0;
duration = 0;
angle = 0;
damage = 0;
baseKnockback = 0;
scalingKnockback = 0;
knockbackType = 0;
shieldDamage = 0;
persistant = 0;
multihit   = 0;

// Who shot the projectile
shotBy = -1;

// Speed and gravity of projectile
vx            = 0;
vy            = 0;
cx            = 0;
cy            = 0;
grav = 0;
airFriction = 0;
facing = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (shotBy.playerCharacter == characters.jackson) shotBy.ammo++;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!persistant) {
    if instance_exists(hitbox) instance_destroy(hitbox);
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Create hitbox
if (hitbox = -1) {
    hitbox = HitboxCreate(xScale, yScale, xOffset, yOffset, duration, angle, damage, baseKnockback, scalingKnockback, knockbackType, shieldDamage, multihit);
}

// Hitbox check
if (hitbox != -1) {
    with (hitbox) {
    
        // Move hitbox
        x = other.x + xOffset;
        y = other.y + yOffset;
        
        // Collision check
        with (oHurtbox) { 
            
            // Ignore self
            if (place_meeting(x,y,other) &amp;&amp; other.owner.shotBy != owner) {

                with (other) {
                    
                    // Check ignore list
                    for (i = 0; i &lt; ds_list_size(ignoreList); i++) {
                        if (ignoreList[|i] == other.owner) {
                            if (!multihit) ignore = true;
                            break;
                        }
                    }
                    
                    // Check if we can hit them
                    if (!ignore &amp;&amp; other.owner.invincibilityFrames == 0) {
                        
                        // Target is shielding
                        if (other.owner.state == states.shielding) {
                            part_particles_create(oGame.particleSystem,x + 8 * other.owner.facing,y-16,oGame.spark,1);
                            other.owner.shieldStrength -= damage * oGame.shieldDamageRatio;
                            other.owner.shieldStrength  -= shieldDamage;
                            ds_list_add(ignoreList, other.owner);
                            if (other.owner.x &gt; owner.x) other.owner.vx += 1; //TODO test shield slide value
                            else                         other.owner.vx -= 1; //"                           "
                        }
                        
                        // Target is countering
                        else if (other.owner.state == states.countering) {
                            
                            // Freeze projectile
                            if (!owner.persistant) {
                                owner.vx = 0;
                                owner.vy = 0;
                            }
                            owner.alarm[0] = 10;
                            
                            // Target counter attacks
                            ds_list_add(ignoreList, other.owner);
                            other.owner.hitBy     = id;
                            other.owner.nextState = states.counterAttacking;
                        }
                        
                        // Confirm the hit
                        else {
                            
                            // Freeze projectile
                            if (!owner.persistant) {
                                owner.vx = 0;
                                owner.vy = 0;
                            }
                            owner.alarm[0] = 10;
                            
                            // Set variables of the defender
                            other.owner.attacking = false;
                            other.owner.hit = true;
                            other.owner.hitBy = id;
                            ds_list_add(ignoreList, other.owner);
                            
                            // Remove defender from ledge if they are grabbing
                            if (other.owner.state == states.ledgeGrabbing) {
                                other.owner.ledgeHeld.ledgeHolder = -1;
                                other.owner.ledgeboxFront.ledgeReset = true;
                            }
                            
                            
                        }
                        
                        
                    }
                }
            }
        }
        // TODO glancing blows on hitbox collision but no hurtbox collision
    }
}

// Apply gravity
vy = Approach(vy, 3.5, grav);

// Apply air friction
vx = Approach(vx, 0, airFriction);

// Remove projectile after duration
if (--duration &lt;= 0) {
    instance_destroy(hitbox);
    instance_destroy();
}

// Move projectile
cx += vx;
cy += vy;
if (cx &gt; 0) vxNew = floor(cx);
else        vxNew = ceil (cx);
if (cy &gt; 0) vyNew = floor(cy);
else        vyNew = ceil (cy);
cx -= vxNew;
cy -= vyNew;


// Vertical
repeat(abs(vyNew)) {
    
    if (!persistant) {    
        // Move normally
        if (!place_meeting(x, y + sign(vyNew), oParSolid) &amp;&amp; !(place_meeting(x, y + 1, oParJumpThru) &amp;&amp; !place_meeting(x, y, oParJumpThru) &amp;&amp; sign(vyNew) &gt;= 0))
            y += sign(vyNew);
        
        // Richochet or stop or slide
        else {
            instance_destroy(hitbox);
            instance_destroy();
        }
    }
    else {
        y += sign(vyNew);
    }
}

// Horizontal
repeat(abs(vxNew)) {     

    if (!persistant) {
        if (!place_meeting(x + sign(vxNew), y, oParSolid) &amp;&amp; !place_meeting(x + sign(vxNew), y, oParSolid)) {
            x += sign(vxNew); 
        }
        else {
            instance_destroy(hitbox);
            instance_destroy();
        }
    }
    else {
        x += sign(vxNew);
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
