<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sBlock</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Initialize movement variables
vx            = 0;
vy            = 0;
cx            = 0;
cy            = 0;
vxTemp        = 0;
vyTemp        = 0;
onGround      = OnGround();
platformBelow = place_meeting(x, y + 1, oParJumpThru);
numJumps      = 0;
airDodgeVert  = 0;
airDodgeHor   = 0;
landingLag    = 0;

// Initialize conditions
canJump       = false;
canUpB        = true;
canDodge      = true;
canThrow      = false;
airDodge      = false;
canAirDodge   = true;
fastFall      = false;
hit           = false;
attacking     = false;
flinching     = false;
tumble        = false;
smashTurn     = false;

// Initialize states
state         = states.helpless;
nextState     = states.helpless;
previousState = states.helpless;

// Initialize timers
windowTimer         = 0;
tempTimer           = 0;
frame               = 0;
holdTimer           = 120;    // Todo, variable hold timer based on damage
hitstun             = 0;
hitlag              = 0;
invincibilityFrames = 0;

// Initialize special variables
hitBy          = -1;
holding        = -1;
ledgeHeld      = -1;
armour         = 0;
maxCombo       = 3;
numA           = 1;
shieldStrength = oGame.maxShieldStrength;

// Hurtbox
hurtbox       = HurtboxCreate(16,32,0,0);

// Ledgeboxes
ledgeboxRear  = LedgeboxRearCreate (24,16,0,0);
ledgeboxFront = LedgeboxFrontCreate(24,16,0,0);

// Hitbox
hitbox = -1;

// Grabbox
grabbox = -1;

// Emitter
emitter = -1;

// Initialize input variables
kLeft          = 0;
kRight         = 0;
kDown          = 0;
kJump          = 0;
kUp            = 0;
kCrouch        = 0;
kSmashLeft     = 0;
kSmashRight    = 0;
kSmashUp       = 0;
kSmashDown     = 0;
kHorizontal    = 0;
kVertical      = 0;
kAttack        = 0;
kAttackHeld    = 0;
kSmash         = 0;
kSmashHeld     = 0;
kSpecialHeld   = 0;
kSpecial       = 0;
kShield        = 0;
kShieldPressed = 0;
kGrab          = 0;
kGrabHeld      = 0;

// Store previous input to detect smash input
pHorizontal = 0;
pVertical   = 0;

audio_play_sound(mRespawnSound,2,0);
audio_sound_gain(mHitSound, 0.5, 0);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> // Apply movement

// Handle sub-pixel movement
var vxNew, vyNew;
cx += vx;
cy += vy;
if (cx &gt; 0) vxNew = floor(cx);
else        vxNew = ceil (cx);
if (cy &gt; 0) vyNew = floor(cy);
else        vyNew = ceil (cy);
cx -= vxNew;
cy -= vyNew;


// Vertical
repeat(abs(vyNew)) {


        // Slide left on angled slopes
        if (place_meeting(x, y - 1, oParSolid) &amp;&amp; place_meeting(x - 1, y - 1, oParSolid) &amp;&amp; !place_meeting(x - 2, y - 1, oParSolid))
            x -= 2;
        else if (place_meeting(x, y - 1, oParSolid) &amp;&amp; !place_meeting(x - 1, y - 1, oParSolid))
            --x;
        
        // Slide left on angled slopes
        if (place_meeting(x, y - 1, oParSolid) &amp;&amp; place_meeting(x + 1, y - 1, oParSolid) &amp;&amp; !place_meeting(x + 2, y - 1, oParSolid))
            x += 2;
        else if (place_meeting(x, y - 1, oParSolid) &amp;&amp; !place_meeting(x + 1, y - 1, oParSolid))
            ++x;
    
        
    // Move normally
    if (!place_meeting(x, y + sign(vyNew), oParSolid) &amp;&amp; !(place_meeting(x, y + 1, oParJumpThru) &amp;&amp; !place_meeting(x, y, oParJumpThru) &amp;&amp; sign(vyNew) &gt;= 0))
        y += sign(vyNew);
    
    // Richochet or stop or slide
    else {
        if ((state == states.hitstun || state == states.hitlag)) vy *= -1;
        else {
            vy = 0;
            cy = 0;
            break;
        }
        
    }
}

// Horizontal
repeat(abs(vxNew)) {     

    // Prevent rolling off the edge
    if (state = states.rolling &amp;&amp; 
        (!place_meeting(x - 10, y + 1, oParSolid) &amp;&amp; !place_meeting(x - 10, y + 1, oParJumpThru) ||
        !place_meeting(x + 10, y + 1, oParSolid) &amp;&amp; !place_meeting(x + 10, y + 1, oParJumpThru))) {
        vx = 0;
        cx = 0
    }
    else if (!place_meeting(x + sign(vxNew), y, oParSolid) &amp;&amp; !place_meeting(x + sign(vxNew), y, oParSolid)) {
        x += sign(vxNew); 
    }
    else {
        if (state == states.hitstun || state == states.hitlag) vx *= -0.8;
        else {
            vx = 0;
            cx = 0;
            break;
        }
        
    }
}

// Move hurtbox
with (hurtbox) {
    x = other.x + xOffset;
    y = other.y + yOffset;
}

// Hitbox check
if (hitbox != -1) {
    with (hitbox) {
    
        // Move hitbox
        x = other.x + xOffset;
        y = other.y + yOffset;
        
        // Collision check
        with (oHurtbox) { 
            
            // Ignore self
            if (place_meeting(x,y,other) &amp;&amp; other.owner != owner) {

                with (other) {
                    
                    // Check ignore list
                    for (i = 0; i &lt; ds_list_size(ignoreList); i++) {
                        if (ignoreList[|i] == other.owner) {
                            if (!multihit) ignore = true;
                            break;
                        }
                    }
                    
                    // Check if we can hit them
                    if (!ignore &amp;&amp; other.owner.invincibilityFrames == 0) {
                        
                        // Target is shielding
                        if (other.owner.state == states.shielding) {
                            part_particles_create(oGame.particleSystem,x + 8 * other.owner.facing,y-16,oGame.spark,1);
                            other.owner.shieldStrength -= damage * oGame.shieldDamageRatio;
                            other.owner.shieldStrength  -= shieldDamage;
                            ds_list_add(ignoreList, other.owner);
                            if (other.owner.x &gt; owner.x) other.owner.vx += 1; //TODO test shield slide value
                            else                         other.owner.vx -= 1; //"                           "
                        }
                        
                        // Target is countering
                        else if (other.owner.state == states.countering) {
                            
                            // Set variables of attacker
                            owner.hitlag = floor(3 + damage/3);
                            owner.previousState = owner.state;
                            owner.nextState = states.hitlag;
                            owner.state     = states.hitlag;
                            owner.attacking = true;
                            owner.vxTemp    = owner.vx;
                            owner.vyTemp    = owner.vy;
                            
                            // Target counter-attacks
                            ds_list_add(ignoreList, other.owner);
                            other.owner.hitBy     = id;
                            other.owner.nextState = states.counterAttacking;
                        }
                        
                        // Confirm the hit
                        else {
                        
                            // Set variables of attacker
                            owner.hitlag = floor(3 + damage/3);
                            owner.previousState = owner.state;
                            owner.nextState = states.hitlag;
                            owner.state     = states.hitlag;
                            owner.attacking = true;
                            owner.vxTemp    = owner.vx;
                            owner.vyTemp    = owner.vy;
                            
                            // Set variables of the defender
                            other.owner.attacking = false;
                            other.owner.hit = true;
                            other.owner.hitBy = id;
                            ds_list_add(ignoreList, other.owner);
                            
                            // Remove defender from ledge if they are grabbing
                            if (other.owner.state == states.ledgeGrabbing) {
                                other.owner.ledgeHeld.ledgeHolder = -1;
                                other.owner.ledgeboxFront.ledgeReset = true;
                            }
                        }

                    }
                }
            }
        }
        // TODO glancing blows on hitbox collision but no hurtbox collision
    }
}

// Grabbox check
if (grabbox != -1) {
    with (grabbox) {
    
        // Move grabbox
        x = other.x + xOffset;
        y = other.y + yOffset;
        
        // Collision check
        with (oHurtbox) { 
            
            // Check for someone we can grab
            if (place_meeting(x,y,other) &amp;&amp; other.owner != owner &amp;&amp; owner.invincibilityFrames == 0 &amp;&amp; owner.state != states.ledgeGrabbing) {

                with (other) {
                    // Set variables of attacker
                    owner.nextState = states.holding;
                    owner.holding   = other.owner;
                    owner.grabbox   = -1;
                    
                    // Set variables of the defender
                    other.owner.nextState = states.held;
                }
            }
        }
    }
}

// Move ledgebox
with(ledgeboxRear) {
    x = other.x - (other.facing + 1) * 12;
    y = other.y - 40;
    
    // Prevent grabbing the ledge in hitstun or hitlag
    if (owner.state != states.hitstun &amp;&amp; owner.state != states.hitlag) {
    
        // Check collision with ledge
        with (oLedge) {
            if (place_meeting(x,y,other) &amp;&amp; ledgeHolder == -1 &amp;&amp; other.canGrab){
                other.owner.facing *= -1;
            }
            
        }  
    } 
    
}

with(ledgeboxFront) {
    x = other.x + (other.facing - 1) * 12;
    y = other.y - 40;
    
    // Prevent grabbing the ledge in hitstun or hitlag
    if (owner.state != states.hitstun &amp;&amp; owner.state != states.hitlag) {
    
        // Check collision with ledge
        with (oLedge) {
            if (place_meeting(x,y,other) &amp;&amp; ledgeHolder == -1 &amp;&amp; !other.ledgeReset &amp;&amp; other.canGrab){
               other.owner.nextState = states.ledgeGrabbing;
               ledgeHolder = other.owner;
               other.owner.ledgeHeld = id;
            }
            
        } 
    } 
}

// Reset jump variables
if (!kJump &amp;&amp; onGround &amp;&amp; state != states.hitstun &amp;&amp; state != states.hitlag) {
    numJumps = 0;
    canJump  = true;
    fastFall = false;
    airDodge = false;
    canUpB   = true;
    ledgeInvincibility = true;
    if (playerCharacter == characters.jackson){
        lunged = 0;
    }
}

// Get hit
if (hit) {

    //if (instance_exists(hitBy))
    GetHit();
}

// Show correct direction of the player
if (facing == 1) {
    image_xscale = 1;
}
else {
    image_xscale = -1;
}

// Check if we die
if ((x &lt; oGame.leftStageBoundary ||
     x &gt; oGame.rightStageBoundary ||
     y &lt; oGame.upperStageBoundary ||
     y &gt; oGame.lowerStageBoundary)
     &amp;&amp; state != states.dead) {
        audio_play_sound(mDeathSound,4,0);
        stocks--;
        nextState = states.dead;
}

// Increment window timer
windowTimer++;

// Reset window timer and animation on state change
if (state != nextState) {
    combo = false;
    windowTimer = 0;
    image_index = 0;
    invincibilityFrames = 0;
    part_emitter_clear(oGame.particleSystem, emitter);
    part_emitter_destroy(oGame.particleSystem, emitter);
    if (hitbox) instance_destroy(hitbox);
}

UpdatePlayerSpecificStats();

// Decrement invincibility frames (if applicable)
invincibilityFrames = max(0, --invincibilityFrames);

// Reduce alpha if invincible
if (invincibilityFrames &gt; 0)  image_alpha = 0.5;
else if (state = states.dead) image_alpha = 0;
else                          image_alpha = 1;

// Update state information
pHorizontal   = kHorizontal;
pVertical     = kVertical;
state         = nextState;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>onGround      = OnGround();
platformBelow = place_meeting(x, y + 1, oParJumpThru);
frame = floor(image_index);


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>GetInput(playerNum);

// Handle Gravity
if (!onGround &amp;&amp; state) {
    
    // Fall normally
    if (!fastFall) vy = Approach(vy, fallSpeed, grav);
    
    // Fast Fall
    else vy = fastFallSpeed;
}

// Replentish shield
if (state != states.shielding) {
    shieldStrength += oGame.shieldRegenerationRate;
    shieldStrength = min(oGame.maxShieldStrength, shieldStrength);
}
// Diminish shield strength
else {
    shieldStrength -= oGame.shieldDepletionRate;
    shieldStrength = max(0, shieldStrength);
}

// State Machine to allow action ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
switch (state) {
    case states.idle:
        StateIdle();
        break;
    case states.walking:
        StateWalking();
        break;
    case states.dashing:
        StateDashing();
        break;
    case states.running:
        StateRunning();
        break;
    case states.skidding:
        StateSkidding();
        break;
    case states.tiltTurning:
        StateTiltTurning();
        break;
    case states.smashTurning:
        StateSmashTurning();
        break;
    case states.runTurning:
        StateRunTurning();
        break
    case states.crouching:
        StateCrouching();
        break;
    case states.crawling:
        StateCrawling();
        break;
    case states.jumping:
        StateJumping();
        break;
    case states.airborne:
        StateAirborne();
        break;
    case states.dead:
        StateDead();
        break;
    case states.hitstun:
        StateHitstun();
        break;
    case states.hitlag:
        StateHitlag();
        break;
    case states.flinching:
        StateFlinching();
        break;
    case states.grounded:
        StateGrounded();
        break;
    case states.tumbling:
        StateTumbling();
        break;
    case states.landing:
        StateLanding();
        break;
        
    case states.fTilt:
        StateFTilt();
        break;
    case states.dTilt:
        StateDTilt();
        break;
    case states.uTilt:
        StateUTilt();
        break;
        
    case states.dashAttacking:
        StateDashAttack();
        break;
    case states.attacking:
        StateAttack();
        break;
        
    case states.fSmash:
        StateFSmash();
        break;
    case states.dSmash:
        StateDSmash();
        break;
    case states.uSmash:
        StateUSmash();
        break;
        
    case states.fCharge:
        StateFCharge();
        break;
    case states.dCharge:
        StateDCharge();
        break;
    case states.uCharge:
        StateUCharge();
        break;
        
    case states.fAir:
        StateFAir();
        break;
    case states.dAir:
        StateDAir();
        break;
    case states.uAir:
        StateUAir();
        break;       
    case states.bAir:
        StateBAir();
        break;  
    case states.nAir:
        StateNAir();
        break; 
    case states.special:
        StateSpecial();
        break;
    case states.fSpecial:
        StateFSpecial();
        break;
    case states.dSpecial:
        StateDSpecial();
        break;
    case states.uSpecial:
        StateUSpecial();
        break; 
    case states.grabbing:
        StateGrabbing();
        break;
    case states.holding:
        StateHolding();
        break;
    case states.held:
        StateHeld();
        break;
    case states.throwing:
        StateThrowing();
        break;
    case states.shielding:
        StateShielding();
        break;
    case states.dodging:
        StateDodging();
        break;
    case states.rolling:
        StateRolling();
        break;
    case states.airDodging:
        StateAirDodging();
        break;
    case states.countering:
        StateCountering();
        break;
    case states.counterAttacking:
        StateCounterAttacking();
        break;
    case states.ledgeGrabbing:
        show_debug_message("grabbed the ledge");
        StateLedgeGrabbing();
        break;
    case states.helpless:
        StateHelpless();
        break;
    case states.getUpAttacking:
        StateGetUpAttacking();
        break;
    case states.gettingUp:
        StateGettingUp();
        break;
    
    default:
        show_debug_message("You forgot a state dumbass");
        game_end();
        break;
        
        
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (instance_exists(self)) draw_self();

// Draw player icon on top of character
if (state == states.idle || state == states.airborne)
draw_sprite(sPlayerIcons,playerNum,x,y - 45);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
